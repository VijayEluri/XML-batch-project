<?xml version="1.0" encoding="UTF-8"?>
<xs:schema attributeFormDefault="qualified"
  elementFormDefault="qualified" id="query"
  targetNamespace="edu.bxml.io" xmlns="edu.bxml.io"
  xmlns:app0="com.browsexml.core" xmlns:app1="edu.bxml.format" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:import namespace="com.browsexml.core" schemaLocation="com_browsexml_core.xsd"/>
  <xs:import namespace="edu.bxml.format" schemaLocation="edu_bxml_format.xsd"/>
  <xs:complexType name="CopyType">
    <xs:complexContent>
      <xs:extension base="FilterType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PgpType">
    <xs:complexContent>
      <xs:extension base="FilterType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
        <xs:attribute form="unqualified" name="privateArmouredKeyFile" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				An .asc file conaining either a public or private key.  If
 decrypting it must match the key used to encrypt.
 
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="passPhrase" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				The phrase used to lock your key file
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType mixed="true" name="MatchesType">
    <xs:complexContent>
      <xs:extension base="FilterType">
        <xs:choice maxOccurs="unbounded" minOccurs="0">
          <xs:element ref="app1:field"/>
        </xs:choice>
        <xs:attribute form="unqualified" name="expression" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				set the regular express used to determine if a line will be processed
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="delimit" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				regular expression to use as the delimiter between fields.  
 for a cvs file this will be ','.  For a pipe separated file it will be
 '\|' since pipe is a special character ('or' symbol) in regular expressions.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="header" type="xs:boolean">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				indicate if there is a header line that names the fields.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="LoadType">
    <xs:complexContent>
      <xs:extension base="MatchesType">
        <xs:choice maxOccurs="unbounded" minOccurs="0">
          <xs:element ref="matches"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AttributeType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
        <xs:attribute form="unqualified" name="attribute" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Should we uncompress the file. If false or missing a compression will be
 done.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="text" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				set the value of the variable.  The 'name' property of the
 variable can be used to reference its value elsewhere using 
 the format ${name}
 @param text
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GZipType">
    <xs:complexContent>
      <xs:extension base="FilterType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
        <xs:attribute form="unqualified" name="unzip" type="xs:boolean">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Should we uncompress the file. If false or missing a compression will be
 done.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PgpEncryptType">
    <xs:complexContent>
      <xs:extension base="FilterType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
        <xs:attribute form="unqualified" name="passPhrase" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				The phrase used to lock your key file
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="decrypt" type="xs:boolean">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Should we decrypt the input
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="keyFile" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				An .asc file conaining either a public or private key. If decrypting it
 must match the key used to encrypt.  A passphrase must be supplied 
 for a private key or a null pointer error will be thrown.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="signersKeyFile" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				The public key of the message signer if that is to be verified.
 This should be a public key and not require a passphrase.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="StreamDecryptVerifyType">
    <xs:complexContent>
      <xs:extension base="PgpEncryptType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TeeType">
    <xs:complexContent>
      <xs:extension base="FilterType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PipeType">
    <xs:complexContent>
      <xs:extension base="FilterType">
        <xs:choice maxOccurs="unbounded" minOccurs="0">
          <xs:element ref="filter"/>
          <xs:element ref="attribute"/>
          <xs:element ref="gZip"/>
          <xs:element ref="pgp"/>
          <xs:element ref="load"/>
          <xs:element ref="streamDecryptVerify"/>
          <xs:element ref="pgpEncrypt"/>
          <xs:element ref="tee"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType mixed="true" name="FilterType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0">
          <xs:element ref="copy"/>
          <xs:element ref="pgp"/>
          <xs:element ref="load"/>
          <xs:element ref="pipe"/>
        </xs:choice>
        <xs:attribute form="unqualified" name="file" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Standard input will come from the dir/file combination.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="toDir" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Standard output will go to the toDir/toFile combination.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="toFile" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Standard output will go to the toDir/toFile combination.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="archive" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Move input file to an archive directory.  The archive directory
 will be created if it does not exist.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="dir" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Standard input will come from the dir/file combination.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="MkdirType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
        <xs:attribute form="unqualified" name="dir" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Specify the directory to be created.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType mixed="true" name="FileObjectType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
        <xs:attribute form="unqualified" name="file" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				File name
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="toDir" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Destination Directory path
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="toFile" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Destination file name
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="dir" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Directory path
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DirType">
    <xs:complexContent>
      <xs:extension base="FileObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IoType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0">
          <xs:element ref="filter"/>
          <xs:element ref="mkdir"/>
          <xs:element ref="copy"/>
          <xs:element ref="gZip"/>
          <xs:element ref="pgp"/>
          <xs:element ref="dir"/>
          <xs:element ref="load"/>
          <xs:element ref="pipe"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="BcPgpType">
    <xs:complexContent>
      <xs:extension base="FilterType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
        <xs:attribute form="unqualified" name="passPhrase" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				The phrase used to lock your key file
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="secretKeyringFile" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				An .asc file conaining either a public or private key. If decrypting it
 must match the key used to encrypt.
 
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CompareType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ConsumerType">
    <xs:choice maxOccurs="unbounded" minOccurs="0"/>
  </xs:complexType>
  <xs:complexType name="ControllerType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType mixed="true" name="CopyOfFilterType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0">
          <xs:element ref="attribute"/>
          <xs:element ref="copy"/>
          <xs:element ref="pgp"/>
          <xs:element ref="load"/>
          <xs:element ref="pipe"/>
        </xs:choice>
        <xs:attribute form="unqualified" name="file" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Standard input will come from the dir/file combination.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="toDir" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Standard output will go to the toDir/toFile combination.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="toFile" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Standard output will go to the toDir/toFile combination.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="archive" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Move input file to an archive directory.  The archive directory
 will be created if it does not exist.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="dir" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Standard input will come from the dir/file combination.
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DaoHibernateType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DeleteType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SMTPAuthenticatorType">
    <xs:choice maxOccurs="unbounded" minOccurs="0"/>
  </xs:complexType>
  <xs:complexType mixed="true" name="EmailType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
        <xs:attribute form="unqualified" name="host" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Location of the Email server
 @param host
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="text" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				Text message in Email body
 @param text
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="subject" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				NO COMMENT
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="password" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				user account's password
 @param password
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="from" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				email address of sender
 @param from
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="toList" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				comma separated list of email recipients
 @param toList
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="filename" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				the name of a file attachment
 @param filename
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="user" type="xs:string">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				user account to access mail server
 @param user
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="FieldValuesType">
    <xs:choice maxOccurs="unbounded" minOccurs="0"/>
  </xs:complexType>
  <xs:complexType name="JspType">
    <xs:complexContent>
      <xs:extension base="CopyType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="MasterDetailType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PipeTestType">
    <xs:choice maxOccurs="unbounded" minOccurs="0"/>
  </xs:complexType>
  <xs:complexType name="PojoType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType mixed="true" name="PrintType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ProducerType">
    <xs:choice maxOccurs="unbounded" minOccurs="0"/>
  </xs:complexType>
  <xs:complexType mixed="true" name="RedirectType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SelectType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ServiceType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SkipFieldType">
    <xs:complexContent>
      <xs:extension base="app1:FieldType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
        <xs:attribute form="unqualified" name="count" type="xs:integer">
          <xs:annotation>
            <xs:documentation><![CDATA[ 
				set the number of fields to skip
 
 @param file
			]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TeeOutputStreamType">
    <xs:choice maxOccurs="unbounded" minOccurs="0"/>
  </xs:complexType>
  <xs:complexType name="TestIoType">
    <xs:choice maxOccurs="unbounded" minOccurs="0"/>
  </xs:complexType>
  <xs:complexType mixed="true" name="TypeTemplateType">
    <xs:complexContent>
      <xs:extension base="app0:XmlObjectType">
        <xs:choice maxOccurs="unbounded" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZIPMachineType">
    <xs:choice maxOccurs="unbounded" minOccurs="0"/>
  </xs:complexType>
  <xs:element name="copy" substitutionGroup="filter" type="CopyType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Copy a file
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="pgp" substitutionGroup="filter" type="PgpType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Encrypt or decrypt a file 
 
 @param file
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="matches" substitutionGroup="filter" type="MatchesType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Process lines for Load that match a regular expression.
 
 @param file
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="load" substitutionGroup="matches" type="LoadType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Load a cvs file into memory.  The file's fields can be delimited
 by any character sequence, not just a comma.  Fields can be merged 
 into a text template file.
 
 @param file
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="attribute" substitutionGroup="app0:xmlObject" type="AttributeType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Get an arbitrary attribute from an object and perhaps run a regular
 expression to transform it.
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="gZip" substitutionGroup="filter" type="GZipType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Compress or Decompress a file
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="pgpEncrypt" substitutionGroup="filter" type="PgpEncryptType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Compress or Decompress a file
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="streamDecryptVerify" substitutionGroup="pgpEncrypt" type="StreamDecryptVerifyType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="tee" substitutionGroup="filter" type="TeeType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Copy a file
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="pipe" substitutionGroup="filter" type="PipeType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Set up a pipeline between classes
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="filter" substitutionGroup="app0:xmlObject" type="FilterType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		A class must extend filter to participate in a pipeline.  Filter can
 be used stand alone as a basic copy from System.in to System.out.
 @author geoff.ritchey
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="mkdir" substitutionGroup="app0:xmlObject" type="MkdirType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Make a directory
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="fileObject" substitutionGroup="app0:xmlObject" type="FileObjectType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Hold file system information
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="dir" substitutionGroup="fileObject" type="DirType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Specify formatting and the query to be formatted as children of this item.
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="io" substitutionGroup="app0:xmlObject" type="IoType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		A container to hold file processing objects.  Its functionality is to call
 execute on all of its children.  Only specifically allows children 
 which are designed to process files.
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="bcPgp" substitutionGroup="filter" type="BcPgpType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Encrypt or decrypt a file - Bouncy Castle
 
 @param file
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="compare" substitutionGroup="app0:xmlObject" type="CompareType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Make a directory
 
 @author ritcheyg
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="consumer" type="ConsumerType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="controller" substitutionGroup="app0:xmlObject" type="ControllerType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="copyOfFilter" substitutionGroup="app0:xmlObject" type="CopyOfFilterType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		A class must extend filter to participate in a pipeline.  Filter can
 be used standalone as a basic copy from System.in to System.out.
 @author geoff.ritchey
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="daoHibernate" substitutionGroup="app0:xmlObject" type="DaoHibernateType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="delete" substitutionGroup="app0:xmlObject" type="DeleteType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="sMTPAuthenticator" type="SMTPAuthenticatorType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="email" substitutionGroup="app0:xmlObject" type="EmailType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 

	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="fieldValues" type="FieldValuesType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="jsp" substitutionGroup="copy" type="JspType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="masterDetail" substitutionGroup="app0:xmlObject" type="MasterDetailType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="pipeTest" type="PipeTestType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="pojo" substitutionGroup="app0:xmlObject" type="PojoType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="print" substitutionGroup="app0:xmlObject" type="PrintType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		A debug tool that sends the contents of the xml tag's body to System.out
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="producer" type="ProducerType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="redirect" substitutionGroup="app0:xmlObject" type="RedirectType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		A debug tool that sends the contents of the xml tag's body to System.out
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="select" substitutionGroup="app0:xmlObject" type="SelectType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="service" substitutionGroup="app0:xmlObject" type="ServiceType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="skipField" substitutionGroup="app1:field" type="SkipFieldType">
    <xs:annotation>
      <xs:documentation><![CDATA[ 
		Used in a Load that doen't have a header line to skip unneeded data.
 
 @param file
	]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="teeOutputStream" type="TeeOutputStreamType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="testIo" type="TestIoType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="typeTemplate" substitutionGroup="app0:xmlObject" type="TypeTemplateType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="zIPMachine" type="ZIPMachineType">
    <xs:annotation>
      <xs:documentation><![CDATA[ ]]></xs:documentation>
    </xs:annotation>
  </xs:element>
</xs:schema>

